q('no')
set.seed(11192008)#
n = 10#
p = 100#
Y = matrix(rnorm(n*p), n, p)#
A = Y %*% t(Y)
svd(A)
#
svdA = svd(A)#
lambda = svdA$d#
u = svdA$u
A %*% u[,1]
lambda[1] * u[,1]
lambda[1] * u[,1,drop=F]
d
lambda
diff(lambda)
-diff(lambda)
A %*% u
A %*% u - u %*% diag(lambda)
epsilon = apply(A %*% u - u %*% diag(lambda), 2, FUN=function(x) {norm(x,'F')})
?norm
epsilon = apply(A %*% u - u %*% diag(lambda), 2, FUN=function(x) {norm(as.matrix(x),'F')})
epsilon
dj[1] = lambda[1] - lambda[2] - (epsilon[1] + epsilon[2])
svdA = svd(A)#
lambda = svdA$d#
u = svdA$u#
k = 5#
dj = matrix(NA, 5, 1)#
epsilon = apply(A %*% u - u %*% diag(lambda), 2, FUN=function(x) {norm(as.matrix(x),'F')})#
dj[1] = lambda[1] - lambda[2] - (epsilon[1] + epsilon[2])
dj
svdA = svd(A)#
lambda = svdA$d#
u = svdA$u#
k = 5#
dj = matrix(NA, 5, 1)#
epsilon = apply(A %*% u - u %*% diag(lambda), 2, FUN=function(x) {norm(as.matrix(x),'F')})#
dj[1] = lambda[1] - lambda[2] - (epsilon[1] + epsilon[2])#
for (kk in 2:k) {#
	first = lambda[kk-1] - lambda[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = lambda[kk] - lambda[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
}
dj
lambda
diff(lambda)
gamma = epsilon[nrow(dj)]/dj
gamma = epsilon[1:nrow(dj)]/dj
gamma
gamma*gamma
sqrt(1 + gamma *gamma)
gamma * sqrt(1 + gamma *gamma)
 #
 # #
 # Test a Variation on Jacobi's Method for Full or Partial Matrix Decomposition#
 ##
 # @author Marc A. Suchard#
 # @author Kenneth Lange#
 # @author Eric C. Chi#
 ##
 #
 library(ggplot2)#
# source("prototype-full.r")#
 #
 music = function(top, bot, n) {#
 	m = n/2#
	new.top = matrix(NA, m, 1)#
	new.bot = matrix(NA, m, 1)#
 	for (k in 1:m) {#
 		if (k == 1)#
 			new.top[1] = 1#
 		else if (k == 2)#
 			new.top[k] = bot[1]#
 		else#
 			new.top[k] = top[k-1]#
 		#
 		if (k == m) #
 			new.bot[k] = top[k]#
 		else#
 			new.bot[k] = bot[k+1]#
 	}#
 	return(list(top=new.top, bot=new.bot))#
 }#
#
 get.all.pairs = function(n) {#
	if ( n %% 2 == 0) {#
		n.partitions = n-1#
		top = seq(1, n, by=2)#
		bot = seq(2, n, by=2)#
	} else {#
		n.partitions = n#
		top = seq(1, n, by=2)#
		bot = c(seq(2, n, by=2), 0)			#
	}#
	all.pairs = vector(mode="list", n.partitions)#
	all.pairs[[1]] = cbind(top, bot)#
	for (i in 2:n.partitions) {#
		chair = music(top, bot, n.partitions+1)#
		top = chair$top#
		bot = chair$bot#
		all.pairs[[i]] = cbind(top, bot)#
	}#
	return(all.pairs)#
 }#
	#
#
 get.A = function(v, lambda) {#
 	return(v %*% lambda %*% t(v))#
 }#
 #
 update.E = function(e, c, s, i, j) {#
 	complement = setdiff(1:nrow(e), c(i,j))#
 	ei = e[i, complement]#
 	ej = e[j, complement]#
 	e[i, complement] = c*ei - s*ej#
 	e[complement, i] = e[i, complement]#
 	e[j, complement] = s*ei + c*ej#
 	e[complement, j] = e[j, complement]#
 	eii = e[i,i]#
 	ejj = e[j,j]#
 	eij = e[i,j]#
 	e[i,i] = c*c*eii - 2*c*s*eij + s*s*ejj#
 	e[j,j] = s*s*eii + 2*c*s*eij + c*c*ejj#
 	e[i,j] = c*s*(eii-ejj) + (c*c - s*s)*eij #
 	e[j,i] = e[i,j]#
 	return(e)#
 }#
#
 get.loss = function(c, s, eii, eij, ejj) {#
 	t.1 = c * c * eii - 2 * c * s * eij + s * s * ejj#
 	t.2 = s * s * eii + 2 * c * s * eij + c * c * ejj#
 	return( t.1 * t.1 + t.2 * t.2 )#
 }#
#
 get.crt.pt = function(eii, eij, ejj) {#
  	a = (eii - ejj) * (eii - ejj)#
 	b = 4 * eij * eij#
 	#
 	if (a + b > 0) {#
	 	x = sqrt(a / (a + b))#
 		r.1 = sqrt(1/2 + 1/2 * x)#
	  	r.2 = sqrt(1/2 - 1/2 * x)#
#
#	l.1 = get.loss(r.1, r.2, eii, eij, ejj)#
#	l.2 = get.loss(r.1, -r.2, eii, eij, ejj)#
#	if ( l.1 > l.2 ) {#
#		return(c(r.1, r.2))#
#	} else {#
#		return(c(r.1, -r.2))#
#	}#
	#
		if ( (eii - ejj) * eij > 0) {#
			r.2 = -r.2#
		}#
	} else {#
		r.1 = 1#
		r.2 = 0#
	} #
	return(c(r.1, r.2))#
 }#
 #
  get.mu.i = function(c, s, eii, eij, ejj) {#
 	return(-1 * (c * c * eii - 2 * c * s * eij + s * s * ejj))#
 }#
 #
 get.mu.j = function(c, s, eii, eij, ejj) {#
 	return(-1 * (s * s * eii + 2 * c * s * eij + c * c * ejj))#
 }#
#
 update.vector.i = function(v.i, v.j, c, s) {#
 	return (c * v.i - s * v.j)#
 }#
 #
 update.vector.j = function(v.i, v.j, c, s) {#
 	return (s * v.i + c * v.j)#
 }#
#
 #
 update.jacobi = function(v, e, lambda, i, j) {#
 	rot = get.crt.pt(e[i,i], e[i,j], e[j,j])#
 	w.i = update.vector.i(v[,i], v[,j], rot[1], rot[2])#
 	w.j = update.vector.j(v[,i], v[,j], rot[1], rot[2]) 	#
 	v[,i] = w.i#
 	v[,j] = w.j#
 	lambda[i,i] = get.mu.i(rot[1], rot[2], e[i,i], e[i,j], e[j,j])#
 	lambda[j,j] = get.mu.j(rot[1], rot[2], e[i,i], e[i,j], e[j,j])#
	e = update.E(e, rot[1], rot[2], i, j)#
 	return(list(v=v, lambda=lambda, e=e)) 	#
 } #
 #
  # Need to handle odd number of basis vectors#
  update.jacobi.all.pairs = function(v, e, lambda) {	n = ncol(v)#
 	n.pairs = n/2#
 	top = seq(1, n, by=2)#
 	bot = seq(2, n, by=2)#
 	for (i in 1:(n-1)) {#
 		for (j in 1:n.pairs) {#
	 		x = update.jacobi(v, e, lambda, top[j], bot[j])#
	 		v = x$v#
	 		lambda = x$lambda#
	 		e = x$e#
	 	}#
 		chairs = music(top, bot, n)#
 		top = chairs$top#
 		bot = chairs$bot	#
 	}#
 	return(list(v=v, lambda=lambda, e=e))#
 }#
 #
  generate.krylov = function(w, Y, m) {#
	Sm = matrix(NA, dim(Y)[1], m)#
	Yt = t(Y)#
	Sm[,1] = w / norm(w,'F')#
	if (m > 1) {#
	 	for (i in 2:m) {#
 			Sm_i = Y %*% (Yt %*% Sm[,i-1])#
			Sm[,i] = Sm_i / norm(Sm_i,'F')#
	 	}#
	 }#
	 return (Sm)#
 }
#
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
# Y = scale(matrix(rnorm(n*p),n,p),center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 50#
 best_k = 5#
 b = matrix(NA, nrow(V), best_k)#
 loss = vector(mode="list", best_k)
best_k
	 lambda = diag(1, nrow=k, ncol=k)#
	 A = get.A(V, lambda)#
##	 E = get.E(V, A, M, lambda)#
     E1 = t(V) %*% Yc #
     E = -E1 %*% t(E1)
E
	 loss[[kk]] = matrix(0, nrow=n.iter+1, ncol=1)#
	 loss[[kk]][1] = norm(A-M, 'F')#
	 VHx = vector(mode="list", length=n.iter)#
	 lambdaHx = vector(mode="list", length=n.iter)#
	 VHx[[1]] = V#
	 lambdaHx[[1]] = lambda#
	 r = dim(V)[2]
iter = 1
		 updates = update.jacobi.all.pairs(V, E, lambda)#
		 lambda = updates$lambda#
		 V = updates$v#
#		 sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
#	  	 V = V[,sort.ix]#
#    	 lambda = diag(diag(lambda)[sort.ix])#
		 E = updates$e#
#		 E = updates$e[sort.ix, sort.ix]#
		 A = get.A(V, lambda)#
#	 E = get.E(V, A, M, lambda)#
#    Keeping history is a time suck!#
	 VHx[[iter+1]] = V#
	 lambdaHx[[iter+1]] = lambda#
		 loss[[kk]][iter+1] = norm(A - M, 'F')
loss
lambda
	  sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	  V = V[,sort.ix]#
	  lambda = diag(diag(lambda)[sort.ix])
lambda
diag(lambda)
diff(diag(lambda))
V
M
M %*% V
M %*% V - V %*% lambda
apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})
epsilon = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})
k = 5#
dj = matrix(NA, k, 1)
dj
lambda = diag(lambda)
lambda
dj[1] = lambda[1] - lambda[2] - (epsilon[1] + epsilon[2])
dj
for (kk in 2:k) {#
	first = lambda[kk-1] - lambda[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = lambda[kk] - lambda[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
}
dj
lambda
epsilon
plot(lambda)
points(lambda+epsilon, pch=16, col='red')
points(lambda-epsilon, pch=16, col='red')
svd(M)
svd(M)$d
diff(svd(M)$d)
lambda
diff(lambda)
plot(lambda[1:4])
points(lambda[1:4]-epsilon[1:4], pch=16, col='red')
points(lambda[1:4]+epsilon[1:4], pch=16, col='red')
plot(lambda[1:4], type='n', ylim=c(40,55))
plot(lambda[1:4])
plot(lambda[1:4], type='n', ylim=c(40,55))
points(lambda[1:4], pch=16)
points(lambda[1:4]+epsilon[1:4], pch=16, col='red')
points(lambda[1:4]-epsilon[1:4], pch=16, col='red')
dj
diff(lambda[1:5])
diff(svd(M)$d[1:5])
		 updates = update.jacobi.all.pairs(V, E, lambda)#
		 lambda = updates$lambda#
		 V = updates$v#
#		 sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
#	  	 V = V[,sort.ix]#
#    	 lambda = diag(diag(lambda)[sort.ix])#
		 E = updates$e#
#		 E = updates$e[sort.ix, sort.ix]#
		 A = get.A(V, lambda)#
#	 E = get.E(V, A, M, lambda)#
#    Keeping history is a time suck!#
	 VHx[[iter+1]] = V#
	 lambdaHx[[iter+1]] = lambda#
		 loss[[kk]][iter+1] = norm(A - M, 'F')
#
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
# Y = scale(matrix(rnorm(n*p),n,p),center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 50#
 best_k = 5#
 b = matrix(NA, nrow(V), best_k)#
 loss = vector(mode="list", best_k)#
#
	 lambda = diag(1, nrow=k, ncol=k)#
	 A = get.A(V, lambda)#
     E1 = t(V) %*% Yc #
     E = -E1 %*% t(E1)#
#
	 loss[[kk]] = matrix(0, nrow=n.iter+1, ncol=1)#
	 loss[[kk]][1] = norm(A-M, 'F')#
	 VHx = vector(mode="list", length=n.iter)#
	 lambdaHx = vector(mode="list", length=n.iter)#
	 VHx[[1]] = V#
	 lambdaHx[[1]] = lambda#
	 r = dim(V)[2]
 for (iter in 1:n.iter) {#
		 updates = update.jacobi.all.pairs(V, E, lambda)#
		 lambda = updates$lambda#
		 V = updates$v#
		 sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	  	 V = V[,sort.ix]#
    	 lambda = diag(diag(lambda)[sort.ix])#
		 E = updates$e[sort.ix, sort.ix]#
		 A = get.A(V, lambda)#
		 VHx[[iter+1]] = V#
		 lambdaHx[[iter+1]] = lambda#
		 loss[[kk]][iter+1] = norm(A - M, 'F')#
	  }
loss
V
V[,1:5]
svd(A)$u
svd(A)$u[,1:5]
V[,1:5]
A %*% V[,1:5]
A %*% V[,1:5] - V[,1:5,drop=F] %*% diag(lambda)
A %*% V[,1:5] - V[,1:5,drop=F] %*% diag(lambda[1:5])
V[,1:5,drop=F] %*% diag(lambda(1:5))
V[,1:5,drop=F] %*% diag(lambda[1:5])
lambda
A %*% V[,1:5] - V[,1:5,drop=F] %*% lambda[1:5,1:5]
epsilon= apply(A %*% V[,1:5] - V[,1:5,drop=F] %*% lambda[1:5,1:5], 2, FUN=function(x){norm(as.matrix(x),'F')}
)
epsilon
 n.iter = 50#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 r = dim(V)[2]	 #
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
  }
loss
VHx
lambdaHx
lambdaHx[[1]]
lambdaHx[[2]]
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
# Y = scale(matrix(rnorm(n*p),n,p),center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 50#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 r = dim(V)[2]	 #
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
	epsilon = apply(A %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
	epsilonHx[[iter+1]] = epsilon#
  }
epsilonHx
#
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 r = dim(V)[2]	 #
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
	epsilon = apply(A %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
	epsilonHx[[iter+1]] = epsilon#
  }
epsilonHx
#
 #
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
# Y = scale(matrix(rnorm(n*p),n,p),center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(A %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 r = dim(V)[2]	 #
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
	epsilon = apply(A %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
	epsilonHx[[iter+1]] = epsilon#
  }
epsilonHx
#
 #
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
# Y = scale(matrix(rnorm(n*p),n,p),center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 r = dim(V)[2]	 #
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
	epsilon = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
	epsilonHx[[iter+1]] = epsilon#
  }
epsilonHx
lambdaHx
lapply(lambdaHx, FUN=function(x){diag})
lapply(lambdaHx, FUN=function(x){diag(x)})
 #
 #
 #
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 djHx = vector(mode="list", length=n.iter)#
 dj = matrix(NA, k, 1)#
 dj[1] = lambda[1] - lambda[2] - (epsilon[1] + epsilon[2])#
 for (kk in 2:k) {#
	first = lambda[kk-1] - lambda[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = lambda[kk] - lambda[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
 }
dj
lambda
best_k
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 djHx = vector(mode="list", length=n.iter)#
 dj = matrix(NA, best_k, 1)#
 dj[1] = lambda[1] - lambda[2] - (epsilon[1] + epsilon[2])#
 for (kk in 2:best_k) {#
	first = lambda[kk-1] - lambda[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = lambda[kk] - lambda[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
 }#
#
 r = dim(V)[2]
dj
epsilon
2*epsilon
lambda
lambda[1]
lambda[2]
 #
 #
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 djHx = vector(mode="list", length=n.iter)#
 dj = matrix(NA, best_k, 1)#
 dj[1] = diag(lambda)[1] - diag(lambda)[2] - (epsilon[1] + epsilon[2])#
 for (kk in 2:best_k) {#
	first = diag(lambda)[kk-1] - diag(lambda)[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = diag(lambda)[kk] - diag(lambda)[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
 }
dj
epsilon
epsilon[1] + epsilon[2]
#
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 djHx = vector(mode="list", length=n.iter)#
 dj = matrix(NA, best_k, 1)#
 dj[1] = diag(lambda)[1] - diag(lambda)[2] - (epsilon[1] + epsilon[2])#
 for (kk in 2:best_k) {#
	first = diag(lambda)[kk-1] - diag(lambda)[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = diag(lambda)[kk] - diag(lambda)[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
 }#
#
 djHx[[1]] = dj#
 r = dim(V)[2]	 #
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
	epsilon = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
	epsilonHx[[iter+1]] = epsilon#
    dj[1] = diag(lambda)[1] - diag(lambda)[2] - (epsilon[1] + epsilon[2])#
    for (kk in 2:best_k) {#
		first = diag(lambda)[kk-1] - diag(lambda)[kk] - (epsilon[kk-1] + epsilon[kk])#
		second = diag(lambda)[kk] - diag(lambda)[kk+1] - (epsilon[kk] + epsilon[kk+1])#
		dj[kk] = min(first, second)#
	}#
	djHx[[iter+1]] = dj#
  }
djHx
#
 #
 #
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 10 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 djHx = vector(mode="list", length=n.iter)#
 dj = matrix(NA, best_k, 1)#
 dj[1] = diag(lambda)[1] - diag(lambda)[2] - (epsilon[1] + epsilon[2])#
 for (kk in 2:best_k) {#
	first = diag(lambda)[kk-1] - diag(lambda)[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = diag(lambda)[kk] - diag(lambda)[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
 }#
 gamma = epsilon[1:nrow(dj)]/dj#
 errorHx = vector(mode="list", length=n.iter)#
 errorHx[[1]] = gamma * sqrt(1 + gamma *gamma)#
#
 djHx[[1]] = dj#
 r = dim(V)[2]
#
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
	epsilon = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
	epsilonHx[[iter+1]] = epsilon#
    dj[1] = diag(lambda)[1] - diag(lambda)[2] - (epsilon[1] + epsilon[2])#
    for (kk in 2:best_k) {#
		first = diag(lambda)[kk-1] - diag(lambda)[kk] - (epsilon[kk-1] + epsilon[kk])#
		second = diag(lambda)[kk] - diag(lambda)[kk+1] - (epsilon[kk] + epsilon[kk+1])#
		dj[kk] = min(first, second)#
	}#
	djHx[[iter+1]] = dj#
	gamma = epsilon[1:nrow(dj)]/dj#
	errorHx[[iter+1]] = gamma * sqrt(1 + gamma *gamma)#
  }
errorHx
V
V[,1:5]
V[,1:5] - svd(M)$u[,1:5]
V[,1:5]
svd(M)$u
svd(M)$u[,1:5]
V[,1:5]
V[,1]
V[,1,drop=F]
V[,1,drop=F] + svd(M)$u[,1,drop=F]
norm(V[,1,drop=F] + svd(M)$u[,1,drop=F],'F')
errorHx
errorHx[[26]]
norm(V[,1,drop=F] + svd(M)$u[,1,drop=F],'F')
norm(V[,2,drop=F] + svd(M)$u[,2,drop=F],'F')
norm(V[,2,drop=F] - svd(M)$u[,2,drop=F],'F')
norm(V[,3,drop=F] + svd(M)$u[,3,drop=F],'F')
norm(V[,3,drop=F] - svd(M)$u[,3,drop=F],'F')
norm(V[,4,drop=F] - svd(M)$u[,4,drop=F],'F')
norm(V[,4,drop=F] + svd(M)$u[,4,drop=F],'F')
 set.seed(1119)#
 n = 20#
 p = 200#
 Y = matrix(rnorm(n*p),n,p)#
 S = svd(Y)#
 S$d[5:20] = 0.01 * S$d[5:20]#
 Y = S$u %*% diag(S$d) %*% t(S$v)#
 Y = scale(Y, center=T)#
 Y = (1/sqrt(dim(Y)[1]))*Y #
 S = svd(Y)#
 #
 M = Y %*% t(Y)#
 w = matrix(rnorm(n),ncol=1)#
 #
 k = 20 #<- Size of basis#
 QRD = qr(generate.krylov(w,Y,k))#
 V = qr.Q(QRD)#
#
 Yc = Y#
  #
 n.iter = 25#
 b = matrix(NA, nrow(V), k)#
 loss = matrix(0, nrow=n.iter+1, ncol=1)#
#
 lambda = diag(1, nrow=k, ncol=k)#
 A = get.A(V, lambda)#
 E1 = t(V) %*% Yc #
 E = -E1 %*% t(E1)#
 loss[1] = norm(A-M, 'F')#
 VHx = vector(mode="list", length=n.iter)#
 lambdaHx = vector(mode="list", length=n.iter)#
 VHx[[1]] = V#
 lambdaHx[[1]] = lambda#
 epsilonHx = vector(mode="list", length=n.iter)#
 epsilonHx[[1]] = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
 djHx = vector(mode="list", length=n.iter)#
 dj = matrix(NA, best_k, 1)#
 dj[1] = diag(lambda)[1] - diag(lambda)[2] - (epsilon[1] + epsilon[2])#
 for (kk in 2:best_k) {#
	first = diag(lambda)[kk-1] - diag(lambda)[kk] - (epsilon[kk-1] + epsilon[kk])#
	second = diag(lambda)[kk] - diag(lambda)[kk+1] - (epsilon[kk] + epsilon[kk+1])#
	dj[kk] = min(first, second)#
 }#
 gamma = epsilon[1:nrow(dj)]/dj#
 errorHx = vector(mode="list", length=n.iter)#
 errorHx[[1]] = gamma * sqrt(1 + gamma *gamma)#
#
 djHx[[1]] = dj#
 r = dim(V)[2]	 #
 for (iter in 1:n.iter) {#
	updates = update.jacobi.all.pairs(V, E, lambda)#
	lambda = updates$lambda#
	V = updates$v#
	sort.ix = sort(diag(lambda), decreasing=T, index.return=T)$ix#
	V = V[,sort.ix]#
    lambda = diag(diag(lambda)[sort.ix])#
	E = updates$e[sort.ix, sort.ix]#
	A = get.A(V, lambda)#
	VHx[[iter+1]] = V#
	lambdaHx[[iter+1]] = lambda#
	loss[iter+1] = norm(A - M, 'F')#
	epsilon = apply(M %*% V - V %*% lambda, 2, FUN=function(x){norm(as.matrix(x),'F')})#
	epsilonHx[[iter+1]] = epsilon#
    dj[1] = diag(lambda)[1] - diag(lambda)[2] - (epsilon[1] + epsilon[2])#
    for (kk in 2:best_k) {#
		first = diag(lambda)[kk-1] - diag(lambda)[kk] - (epsilon[kk-1] + epsilon[kk])#
		second = diag(lambda)[kk] - diag(lambda)[kk+1] - (epsilon[kk] + epsilon[kk+1])#
		dj[kk] = min(first, second)#
	}#
	djHx[[iter+1]] = dj#
	gamma = epsilon[1:nrow(dj)]/dj#
	errorHx[[iter+1]] = gamma * sqrt(1 + gamma *gamma)#
  }
errrorHx
errorHx
V
V - svd(M)$u
svd(M)$u
V
t(V) %*% svd(M)$u
q('no')
lambda = runif(20)
lambda
as.matrix(lambda)
epsilon = 0.1 * runif(20)
epsilon
q('no')
ls()
load('Simulated_Annealing_local_min.rda')
ls()
  library(ggplot2)#
  library(stringr)#
  setwd('~/Dropbox/Research/Sudoku/Tests/top95')#
  source('~/Dropbox/Research/Sudoku/sudoku.R')#
  source('~/Dropbox/Research/Sudoku/Methods/projection/projection.R')#
  source('~/Dropbox/Research/Sudoku/Methods/simulated_annealing/call_sudoku_by_simulated_annealing.R')
Q = tensor_to_answer(vector_to_tensor(sol$q))#
Q = cbind(9.5-coordinate_rep(Q)[,1:2],coordinate_rep(Q)[,3])
Q
q('no')
